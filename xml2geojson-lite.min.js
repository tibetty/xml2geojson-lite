!function(){return function e(t,r,s){function o(i,n){if(!r[i]){if(!t[i]){var l="function"==typeof require&&require;if(!n&&l)return l(i,!0);if(a)return a(i,!0);var p=new Error("Cannot find module '"+i+"'");throw p.code="MODULE_NOT_FOUND",p}var u=r[i]={exports:{}};t[i][0].call(u.exports,function(e){return o(t[i][1][e]||e)},u,u.exports,e,t,r,s)}return r[i].exports}for(var a="function"==typeof require&&require,i=0;i<s.length;i++)o(s[i]);return o}}()({1:[function(require,module,exports){const XmlParser=require("./xmlparser.js");module.exports=((osm,opts)=>{let first=e=>e[0],last=e=>e[e.length-1],coordsToKey=e=>e.join(","),addToMap=(e,t,r)=>{let s=e[t];s?s.push(r):e[t]=[r]},removeFromMap=(e,t,r)=>{let s=e[t];s&&s.splice(s.indexOf(r),1)},getFirstFromMap=(e,t)=>{let r=e[t];return r&&r.length>0?r[0]:null};class Ways{constructor(){this.ways=[],this.firstMap={},this.lastMap={}}add(e){this.ways.push(e);let t=coordsToKey(first(e)),r=coordsToKey(last(e));addToMap(this.firstMap,t,e),addToMap(this.lastMap,r,e)}toRings(e){let t=e=>coordsToKey(first(e))===coordsToKey(last(e)),r=e=>e instanceof Array?e.map(r):parseFloat(e),s=(e,t,r)=>{t=t||0,r=r||1;let s=e.reduce((t,r,s)=>e[t][0]>r[0]?t:s,0),o=s<=0?e.length-1:s-1,a=s>=e.length-1?0:s+1,i=e[o][t],n=e[s][t],l=e[a][t],p=e[o][r],u=e[s][r];return(n-i)*(e[a][r]-p)-(l-i)*(u-p)<0?"clockwise":"counterclockwise"},o=[],a=null;for(;a=this.ways.shift();)if(removeFromMap(this.firstMap,coordsToKey(first(a)),a),removeFromMap(this.lastMap,coordsToKey(last(a)),a),t(a))s(a=r(a))!==e&&a.reverse(),o.push(a);else{let i=[],n=a,l=!1;for(;n;){i=i.concat(n);let e=coordsToKey(last(i));l=!1,(n=getFirstFromMap(this.firstMap,e))||(n=getFirstFromMap(this.lastMap,e),l=!0),n&&(this.ways.splice(this.ways.indexOf(n),1),removeFromMap(this.firstMap,coordsToKey(first(n)),n),removeFromMap(this.lastMap,coordsToKey(last(n)),n),l&&n.reverse(),n=n.slice(1))}t(i)&&(s(i=r(i))!==e&&i.reverse(),o.push(i))}return o}}let innerWays=new Ways,outerWays=new Ways,features=[],relProps={};const xmlParser=new XmlParser({progressive:!0});xmlParser.addListener("</osm.relation.member>",node=>{with(node)if("way"===$type){let way=[];for(let innerNode of innerNodes)way.push([innerNode.$lon,innerNode.$lat]);"inner"===$role?innerWays.add(way):"outer"===$role&&outerWays.add(way)}else opts&&opts.allFeatures&&"node"===$type&&features.push({type:"Feature",id:`node/${$ref}`,properties:{id:`node/${$ref}`,role:$role},geometry:{type:"Point",coordinates:[parseFloat($lon),parseFloat($lat)]}})}),opts&&opts.allFeatures&&(xmlParser.addListener("<osm.relation>",e=>relProps.id="relation/"+e.$id),xmlParser.addListener("<osm.relation.bounds>",e=>relProps.bbox=[parseFloat(e.$minlon),parseFloat(e.$minlat),parseFloat(e.$maxlon),parseFloat(e.$maxlat)]),xmlParser.addListener("</osm.relation.tag>",e=>relProps[e.$k]=e.$v)),xmlParser.parse(osm);let constructGeometry=(e,t)=>{let r=e.toRings("counterclockwise"),s=t.toRings("clockwise"),o=(e,t,r,s)=>{r=r||0,s=s||1;let o=!1;for(let a=0,i=t.length-1;a<t.length;i=a++)(t[a][r]<=e[r]&&e[r]<t[i][r]||t[i][r]<=e[r]&&e[r]<t[a][r])&&e[s]<(t[i][s]-t[a][s])*(e[r]-t[a][r])/(t[i][r]-t[a][r])+t[a][s]&&(o=!o);return o},a=[];for(let e in r)a[e]=[r[e]];let i=null;for(;i=s.shift();)for(let e in r)if(o(first(i),r[e])){a[e].push(i);break}return 1===a.length?{type:"Polygon",coordinates:a[0]}:{type:"MultiPolygon",coordinates:a}},geometry=constructGeometry(outerWays,innerWays);return opts&&opts.allFeatures?(features.unshift({type:"Feature",id:relProps.id,properties:relProps,geometry:geometry}),{type:"FeatureCollection",features:features}):geometry})},{"./xmlparser.js":2}],2:[function(e,t,r){t.exports=class{constructor(e){e&&(this.queryParent=!!e.queryParent,this.progressive=e.progressive,this.queryParent&&(this.parentMap=new WeakMap)),this.evtListeners={}}parse(e,t,r){r=r?r+".":"";let s=/<([^ >\/]+)(.*?)>/g,o=null,a=[];for(;o=s.exec(e);){let i=o[1],n={tag:i},l=r+i,p=!1,u=/([^ ]+?)="(.+?)"/g,d=o[2].trim(),f=null;(d.endsWith("/")||i.startsWith("?")||i.startsWith("!"))&&(p=!0);let h=!1;for(;f=u.exec(d);)h=!0,n[`$${f[1]}`]=f[2];if(h||""===d||(n.text=d),this.progressive&&this.emit(`<${l}>`,n,t),!p){let t=new RegExp(`([^]+?)</${i}>`,"g");t.lastIndex=s.lastIndex;let r=t.exec(e);if(r&&r[1]){s.lastIndex=t.lastIndex;let e=this.parse(r[1],n,l);e.length>0?n.innerNodes=e:n.innerText=r[1]}}this.queryParent&&t&&this.parentMap.set(n,t),this.progressive&&this.emit(`</${l}>`,n,t),a.push(n)}return a}getParent(e){return this.queryParent?this.parentMap.get(e):null}addListener(e,t){let r=this.evtListeners[e];r?r.push(t):this.evtListeners[e]=[t]}removeListener(e,t){let r=this.evtListeners[e];r&&r.splice(r.indexOf(t),1)}emit(e,...t){let r=this.evtListeners[e];if(r)for(let e of r)e.apply(null,t)}on(e,t){this.addListener(e,t)}off(e,t){this.removeListener(e,t)}}},{}]},{},[1]);