!function(){return function e(t,r,s){function o(i,a){if(!r[i]){if(!t[i]){var l="function"==typeof require&&require;if(!a&&l)return l(i,!0);if(n)return n(i,!0);var d=new Error("Cannot find module '"+i+"'");throw d.code="MODULE_NOT_FOUND",d}var p=r[i]={exports:{}};t[i][0].call(p.exports,function(e){return o(t[i][1][e]||e)},p,p.exports,e,t,r,s)}return r[i].exports}for(var n="function"==typeof require&&require,i=0;i<s.length;i++)o(s[i]);return o}}()({1:[function(require,module,exports){const XmlParser=require("./xmlparser.js");module.exports=((osm,opts)=>{let first=e=>e[0],last=e=>e[e.length-1],coordsToKey=e=>e.join(","),addToMap=(e,t,r)=>{let s=e[t];s?s.push(r):e[t]=[r]},removeFromMap=(e,t,r)=>{let s=e[t];s&&s.splice(s.indexOf(r),1)},getFirstFromMap=(e,t)=>{let r=e[t];return r&&r.length>0?r[0]:null},strToFloat=e=>e instanceof Array?e.map(strToFloat):parseFloat(e);class Ways{constructor(){this.ways=[],this.firstMap={},this.lastMap={}}add(e){this.ways.push(e),addToMap(this.firstMap,coordsToKey(first(e)),e),addToMap(this.lastMap,coordsToKey(last(e)),e)}toRings(e){let t=e=>coordsToKey(first(e))===coordsToKey(last(e)),r=(e,t,r)=>{t=t||0,r=r||1;let s=e.reduce((r,s,o)=>e[r][t]>s[t]?r:o,0),o=s<=0?e.length-1:s-1,n=s>=e.length-1?0:s+1,i=e[o][t],a=e[s][t],l=e[n][t],d=e[o][r],p=e[s][r];return(a-i)*(e[n][r]-d)-(l-i)*(p-d)<0?"clockwise":"counterclockwise"},s=this.toStrings(),o=[],n=null;for(;n=s.shift();)t(n)&&(r(n)!=e&&n.reverse(),o.push(n));return o}toStrings(){let e=[],t=null;for(;t=this.ways.shift();){removeFromMap(this.firstMap,coordsToKey(first(t)),t),removeFromMap(this.lastMap,coordsToKey(last(t)),t);let r=t,s=null;do{let e=coordsToKey(last(r)),t=!1;(s=getFirstFromMap(this.firstMap,e))||(s=getFirstFromMap(this.lastMap,e),t=!0),s&&(this.ways.splice(this.ways.indexOf(s),1),removeFromMap(this.firstMap,coordsToKey(first(s)),s),removeFromMap(this.lastMap,coordsToKey(last(s)),s),t&&(s.length>r.length&&([r,s]=[s,r]),s.reverse()),r=r.concat(s.slice(1)))}while(s);e.push(strToFloat(r))}return e}}let constructGeometry=e=>{return e.outerWays?((e,t)=>{let r=e?e.toRings("counterclockwise"):[],s=t?t.toRings("clockwise"):[],o=(e,t,r,s)=>{r=r||0,s=s||1;let o=!1;for(let n=0,i=t.length-1;n<t.length;i=n++)(t[n][r]<=e[r]&&e[r]<t[i][r]||t[i][r]<=e[r]&&e[r]<t[n][r])&&e[s]<(t[i][s]-t[n][s])*(e[r]-t[n][r])/(t[i][r]-t[n][r])+t[n][s]&&(o=!o);return o},n=[],i=null;for(i of r)n.push([i]);for(;i=s.shift();)for(let e in r)if(o(first(i),r[e])){n[e].push(i);break}return 1===n.length?{type:"Polygon",coordinates:n[0]}:{type:"MultiPolygon",coordinates:n}})(e.outerWays,e.innerWays):e.ways?(e=>{let t=e?e.toStrings():[];return 1===t.length?{type:"LineString",coordinates:t[0]}:{type:"MultiLineString",coordinates:t}})(e.ways):null},nodes={},ways={},relations={},points=[],strings=[],polygons=[];const xmlParser=new XmlParser({progressive:!0});return xmlParser.addListener("<osm.relation>",e=>{relations[e.$id]={type:"Feature",id:`relation/${e.$id}`,properties:{id:`relation/${e.$id}`}}}),xmlParser.addListener("</osm.way>",node=>{with(node){let way=[];if(node.innerNodes)for(let nd of node.innerNodes)if(nd.$lon&&nd.$lat)way.push([nd.$lon,nd.$lat]);else if(nd.$ref){let rnd=nodes[nd.$ref];rnd&&way.push(rnd)}ways[$id]=way}}),xmlParser.addListener("</osm.node>",node=>{with(node)nodes[$id]=[$lon,$lat]}),xmlParser.addListener('</osm.relation.member[$type==="way"]>',(node,parent)=>{const roleToWaysName={inner:"innerWays",outer:"outerWays","":"ways"};with(node){node.$role||(node.$role="");let waysName=roleToWaysName[$role],_ways=relations[parent.$id][waysName];_ways||(_ways=relations[parent.$id][waysName]=new Ways);let way=[];if(node.innerNodes){for(let nd of node.innerNodes)if(nd.$lon&&nd.$lat)way.push([nd.$lon,nd.$lat]);else if(nd.$ref){let rnd=nodes[nd.$ref];rnd&&way.push(rnd)}}else way=ways[$ref];_ways.add(way)}}),xmlParser.addListener("</osm.relation>",e=>{let t=relations[e.$id];if(t.geometry=constructGeometry(t),delete t.outerWays,delete t.innerWays,delete t.ways,delete relations[e.$id],t.geometry)switch(t.geometry.type){case"Polygon":case"MultiPolygon":polygons.push(t);break;case"LineString":case"MultiLineString":strings.push(t)}}),xmlParser.addListener("</osm.relation.bounds>",(e,t)=>relations[t.$id].properties.bbox=[parseFloat(e.$minlon),parseFloat(e.$minlat),parseFloat(e.$maxlon),parseFloat(e.$maxlat)]),xmlParser.addListener("</osm.relation.tag>",(e,t)=>relations[t.$id].properties[e.$k]=e.$v),xmlParser.addListener('</osm.relation.member[$type==="node"]>',node=>{with(node){let feature={type:"Feature",id:`node/${$ref}`,properties:{id:`node/${$ref}`,role:$role}};if(node.$lon&&node.$lat)feature.geometry={type:"Point",coordinates:[parseFloat($lon),parseFloat($lat)]};else{let nd=nodes[$ref];nd&&(feature.geometry={type:"Point",coordinates:strToFloat(nd)})}points.push(feature)}}),xmlParser.parse(osm),opts&&opts.allFeatures?{type:"FeatureCollection",features:polygons.concat(strings).concat(points)}:polygons[0].geometry})},{"./xmlparser.js":2}],2:[function(e,t,r){t.exports=(()=>{function e(e){return null!=e.match(/^(.+?)\[(.+?)\]>$/g)}function t(e){let t=/^(.+?)\[(.+?)\]>$/g.exec(e);return t?{evt:t[1]+">",exp:t[2]}:{evt:e}}return class{constructor(e){e&&(this.queryParent=!!e.queryParent,this.progressive=e.progressive,this.queryParent&&(this.parentMap=new WeakMap)),this.evtListeners={}}parse(e,t,r){r=r?r+".":"";let s=/<([^ >\/]+)(.*?)>/gm,o=null,n=[];for(;o=s.exec(e);){let i=o[1],a={tag:i},l=r+i,d=o[2].trim(),p=!1;(d.endsWith("/")||i.startsWith("?")||i.startsWith("!"))&&(p=!0);let u=/([^ ]+?)="(.+?)"/g,y=null,c=!1;for(;y=u.exec(d);)c=!0,a[`$${y[1]}`]=y[2];if(c||""===d||(a.text=d),this.progressive&&this.emit(`<${l}>`,a,t),!p){let t=new RegExp(`([^]+?)</${i}>`,"g");t.lastIndex=s.lastIndex;let r=t.exec(e);if(r&&r[1]){s.lastIndex=t.lastIndex;let e=this.parse(r[1],a,l);e.length>0?a.innerNodes=e:a.innerText=r[1]}}this.queryParent&&t&&this.parentMap.set(a,t),this.progressive&&this.emit(`</${l}>`,a,t),n.push(a)}return n}getParent(e){return this.queryParent?this.parentMap.get(e):null}$addListener(e,t){let r=this.evtListeners[e];r?r.push(t):this.evtListeners[e]=[t]}addListener(r,s){e(r)&&(r=t(r),s.condition=function(e){let t="return "+e.replace(/(\$.+?)(?=[=!.])/g,"node.$&")+";";return new Function("node",t)}(r.exp),r=r.evt),this.$addListener(r,s)}$removeListener(e,t){let r=this.evtListeners[e];r&&r.splice(r.indexOf(t),1)}removeListener(r,s){e(r)&&(r=(r=t(r)).evt),this.$removeListener(r,s)}emit(e,...t){let r=this.evtListeners[e];if(r)for(let e of r)e.condition?!0===e.condition.apply(null,t)&&e.apply(null,t):e.apply(null,t)}on(e,t){this.addListener(e,t)}off(e,t){this.removeListener(e,t)}}})()},{}]},{},[1]);